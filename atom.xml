<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>宁立新的个人博客</title>
  
  
  <link href="https://ninglixin98.github.io/atom.xml" rel="self"/>
  
  <link href="https://ninglixin98.github.io/"/>
  <updated>2022-06-09T12:06:06.809Z</updated>
  <id>https://ninglixin98.github.io/</id>
  
  <author>
    <name>宁立新</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SV 第一章 —— 数据类型、方法和过程块</title>
    <link href="https://ninglixin98.github.io/2022/06/09/sv1/"/>
    <id>https://ninglixin98.github.io/2022/06/09/sv1/</id>
    <published>2022-06-09T11:39:52.000Z</published>
    <updated>2022-06-09T12:06:06.809Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SV-第一章-——-数据类型、方法和过程块"><a href="#SV-第一章-——-数据类型、方法和过程块" class="headerlink" title="SV 第一章 —— 数据类型、方法和过程块"></a>SV 第一章 —— 数据类型、方法和过程块</h1><h2 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1. 数据类型"></a>1. 数据类型</h2><h3 id="1-1-内建数据类型"><a href="#1-1-内建数据类型" class="headerlink" title="1.1 内建数据类型"></a>1.1 内建数据类型</h3><ul><li><p>SV中引入了新的数据类型：logic和bit。logic为无符号四值逻辑，bit为无符号二值逻辑。</p></li><li><p>变量类型分类</p><ul><li><p>按逻辑类型分</p><ul><li>四值逻辑类型：integer、logic、reg、net-type(wire、tri)</li><li>二值逻辑：byte、shortint、int、longint、bit</li></ul></li><li><p>按有无符号分</p><ul><li>有符号类型：byte、shortint、int、longint、integer</li><li>无符号类型：bit、logic、reg、net-type</li></ul></li></ul></li><li><p>浮点类型</p><ul><li><p>SV：添加 shortreal 用来表示32位单精度浮点类型</p></li><li><p>verilog：real表示双精度浮点类型</p></li></ul></li><li><p>类型的转换</p><ul><li>方法：目标类型’(原数据)</li></ul></li></ul><h3 id="1-2-定宽数组"><a href="#1-2-定宽数组" class="headerlink" title="1.2 定宽数组"></a>1.2 定宽数组</h3><h4 id="1-2-1-数组的声明"><a href="#1-2-1-数组的声明" class="headerlink" title="1.2.1 数组的声明"></a>1.2.1 数组的声明</h4><ul><li><p>一维数组</p><ul><li><code>int lo_hi [0:15];</code></li></ul></li><li><p>多维数组</p><ul><li><p>完整声明</p><ul><li><code>int array2 [0:7][0:3];</code></li></ul></li><li><p>紧凑声明</p><ul><li><code>int array2 [8][4];</code></li></ul></li><li><p>设置最后一个原素</p><ul><li><code>int array2 [7][3] = 1;</code></li></ul></li><li><p>定宽数组中，数组下标和位下标可以同时使用</p><ul><li><code>src[0][2:1];</code></li></ul></li></ul></li></ul><h4 id="1-2-2-多维数组类型"><a href="#1-2-2-多维数组类型" class="headerlink" title="1.2.2 多维数组类型"></a>1.2.2 多维数组类型</h4><ul><li><p>组合型（packed）</p><ul><li><p><code>bit [3][7:0] b_pack;</code></p></li><li><p>左边为高维数组，右边为低维数组</p></li><li><p>数组高维是连续排列的，连续存储在一个word里，占用内存少</p></li><li><p>SV相比于verilog，扩展了组合型数组的类型，包括event、bit、bit、logic、int、longint、shortreal、real类型</p></li><li><p>4值数据的数组占据的空间要乘2</p></li></ul></li><li><p>非组合型unpacked</p><ul><li><p><code>bit [7:0] b_unpack [3];</code></p></li><li><p><code>bit b_unpack [3][7:0];</code></p></li><li><p>数组名右边为高维，左边为低维</p></li><li><p>数组高维是不连续的，分别存储在3个不同的word里，占用内存多</p></li><li><p>4值数据的数组占据的空间要乘2</p></li></ul></li><li><p>混合型数组</p><ul><li><p><code>int [2][3] arr [4][5];</code></p></li><li><p>数组维度从高到低先看右边</p></li><li><p>从高维到低维：4*5*2*3</p></li></ul></li></ul><h4 id="1-2-3-数组的初始化和赋值"><a href="#1-2-3-数组的初始化和赋值" class="headerlink" title="1.2.3 数组的初始化和赋值"></a>1.2.3 数组的初始化和赋值</h4><ul><li><p>一维数组</p><ul><li><p>格式为：数据类型 数组名 [位宽] &#x3D; ‘{数值1,数值2,…..};</p></li><li><p><code>int ascend [4] = &#39;&#123;0,1,2,3&#125;;</code></p></li></ul></li><li><p>多维数组</p><ul><li><p>组合型</p><ul><li><p>因为是连续的，和向量一样，使用{}，不需要加’</p></li><li><p><code>logic [3:0][7:0] a = 32&#39;h0;</code></p></li><li><p><code>logic [3:0][7:0] a = &#123;16&#39;hz,16&#39;h0&#125;;</code></p></li><li><p>使用连接符合时必须标明位宽，否则默认为32位</p></li><li><p>左右两边大小和维度不同时，也可以进行操作</p></li></ul></li><li><p>非组合型</p><ul><li><p>需要对每一个数进行赋值，使用’{}</p></li><li><p><code>int d[0:1][0:3] = &#39;&#123;&#39;&#123;1,2,3,4&#125;,&#39;&#123;5,6,7,8&#125;&#125;;</code></p></li><li><p>注意：二维数组一定要有2层{}</p></li><li><p>也可以用’{default:}全部赋值默认值</p></li><li><p><code>int d[0:1][0:3] = &#39;&#123;default: 8&#39;h55&#125;;</code></p></li><li><p>左右大小和维度必须严格一致</p></li></ul></li></ul></li></ul><h4 id="1-2-4-数组循环"><a href="#1-2-4-数组循环" class="headerlink" title="1.2.4 数组循环"></a>1.2.4 数组循环</h4><ul><li><p>for 循环</p><ul><li><p><code>for (int i = 0; $size(src); i++)</code></p></li><li><p>$size(数组名) 可以获取数组的长度</p></li></ul></li><li><p>foreach 循环</p><ul><li><p>一维数组 </p><ul><li><p><code>foreach(dust[j])</code></p></li><li><p>foreach比较方便，无需声明变量j即可使用，遍历从0到j的所有元素</p></li></ul></li><li><p>多维数组</p><ul><li><p>遍历全部数组</p><ul><li><code>foreach(md[i,j])</code></li></ul></li><li><p>遍历高维数组</p><ul><li><code>foreach(md[i])</code></li></ul></li><li><p>遍历低维数组</p><ul><li><code>foreach(md[,j] )</code></li></ul></li></ul></li></ul></li></ul><h4 id="1-2-5-数组的系统函数"><a href="#1-2-5-数组的系统函数" class="headerlink" title="1.2.5 数组的系统函数"></a>1.2.5 数组的系统函数</h4><ul><li><p>$dimensions(arr_name) 返回数组维度</p></li><li><p>$left(arr_name, dimension) 返回指定维度的最左索引值</p></li><li><p>$size(arr_name, dimension) 返回指定维度的数组大小</p></li><li><p>$increment(arr_name, dimension) 返回指定维度最左的索引值是否大于等于最右的索引值，是返回1，否返回-1</p></li><li><p>$bits(expression) 返回数组存储的比特数目</p></li></ul><h4 id="1-2-6-数组的复制和比较"><a href="#1-2-6-数组的复制和比较" class="headerlink" title="1.2.6 数组的复制和比较"></a>1.2.6 数组的复制和比较</h4><ul><li><p>复制</p><ul><li>使用 &#x3D;</li></ul></li><li><p>比较</p><ul><li><p>使用数组循环比较每一个原素</p></li><li><p>直接使用&#x3D;&#x3D; 和 !&#x3D; 对两个数组直接操作</p></li></ul></li></ul><h4 id="1-2-7-数组的方法"><a href="#1-2-7-数组的方法" class="headerlink" title="1.2.7 数组的方法"></a>1.2.7 数组的方法</h4><ul><li><p>数组缩减方法</p><ul><li><p>数组求和</p><ul><li><p><code>on.sum;</code></p></li><li><p>需要注意位宽</p></li></ul></li><li><p>数组求积</p><ul><li><code>on.product;</code></li></ul></li><li><p>数组与</p><ul><li><code>on.and;</code></li></ul></li><li><p>数组或</p><ul><li><code>on.or;</code></li></ul></li><li><p>数组异或</p><ul><li><code>on.xor;</code></li></ul></li></ul></li><li><p>数组定位方法</p><ul><li><p>找出最大值</p><ul><li><code>q.min();</code></li></ul></li><li><p>找出最小值</p><ul><li><code>q.max();</code></li></ul></li><li><p>找出具有唯一值的队列</p><ul><li><code>q.unique();</code></li></ul></li><li><p>定位方法find</p><ul><li><p>find</p><ul><li><p>find_index;</p></li><li><p>find_first;</p></li><li><p>find_last;</p></li><li><p>find_first_index;</p></li><li><p>find_last_index;</p></li></ul></li><li><p>表达式with(item)</p><ul><li><p>tq &#x3D; d.find with (item &gt; 3);</p></li><li><p>返回大于3的值</p></li></ul></li></ul></li></ul></li></ul><h3 id="1-3-动态数组"><a href="#1-3-动态数组" class="headerlink" title="1.3 动态数组"></a>1.3 动态数组</h3><ul><li><p>可以在运行过程中调整大小</p><h4 id="1-3-1-声明"><a href="#1-3-1-声明" class="headerlink" title="1.3.1 声明"></a>1.3.1 声明</h4></li><li><p><code>int dyn [];</code></p></li><li><p>重新分配大小</p><ul><li><p><code>dyn = new [5];</code></p></li><li><p>动态数组可以通过new随时改变大小</p></li><li><p>dyn &#x3D; new [20] (dyn);</p></li><li><p>重新分配大小并拷贝原数组dyn</p></li></ul></li></ul><h4 id="1-3-2-动态数组内建的子程序"><a href="#1-3-2-动态数组内建的子程序" class="headerlink" title="1.3.2 动态数组内建的子程序"></a>1.3.2 动态数组内建的子程序</h4><ul><li><p>删除所有元素</p><ul><li><code>dyn.delete();</code></li></ul></li><li><p>获取数组大小</p><ul><li><code>dyn.size();</code></li></ul></li></ul><h3 id="1-4-队列"><a href="#1-4-队列" class="headerlink" title="1.4 队列"></a>1.4 队列</h3><ul><li>可以在任何地方添加、删除、访问元素</li></ul><h4 id="1-4-1-声明"><a href="#1-4-1-声明" class="headerlink" title="1.4.1  声明"></a>1.4.1  声明</h4><ul><li><p><code>q[$];</code></p></li><li><p>使用$符号的下标</p></li></ul><h4 id="1-4-2-赋值"><a href="#1-4-2-赋值" class="headerlink" title="1.4.2 赋值"></a>1.4.2 赋值</h4><ul><li><p><code>q[$] = &#123;2,3&#125;;</code></p></li><li><p>{}前不加’</p></li><li><p>索引值从左到右为0，1，2…</p></li></ul><h4 id="1-4-3-队列方法"><a href="#1-4-3-队列方法" class="headerlink" title="1.4.3 队列方法"></a>1.4.3 队列方法</h4><ul><li><p>在X位置插入元素X</p><ul><li><p><code>q.insert(1,4);</code></p></li><li><p>在第二个元素前插入4</p></li></ul></li><li><p>放入元素</p><ul><li><p><code>q.push_back(5);</code></p></li><li><p>从尾部放入</p></li><li><p><code>q.push_front();</code></p></li><li><p>从头部放入</p></li></ul></li><li><p>取出元素</p><ul><li><p><code>q.pop_front();</code></p></li><li><p>从头部取出</p></li><li><p><code>q.pop_back();</code></p></li><li><p>从尾部取出</p></li></ul></li><li><p>删除元素</p><ul><li><code>q.delete();</code></li></ul></li><li><p>注意：使用pop方法时要注意队列不能为空，否则会报错。</p></li><li><p>在方法中对队列进行操作时，需要在参数列表处加上ref。</p></li></ul><h3 id="1-5-关联数组"><a href="#1-5-关联数组" class="headerlink" title="1.5 关联数组"></a>1.5 关联数组</h3><ul><li>用来保存稀疏矩阵的元素</li></ul><h4 id="1-5-1-声明"><a href="#1-5-1-声明" class="headerlink" title="1.5.1 声明"></a>1.5.1 声明</h4><ul><li><p>关联数组采用在方括号中放置数据类型的形式来进行声明，数组名左边为存放的数据的类型，右边为地址值的类型。</p></li><li><p><code>bit [63:0] assoc [int];</code></p><h4 id="1-5-2-方法"><a href="#1-5-2-方法" class="headerlink" title="1.5.2 方法"></a>1.5.2 方法</h4></li><li><p>找到并删除第一个元素</p></li><li><p>assoc.first(idx);<br> assoc.delete(idx);</p></li></ul><h3 id="1-6-结构体"><a href="#1-6-结构体" class="headerlink" title="1.6 结构体"></a>1.6 结构体</h3><ul><li><p>结构体表示变量的合集</p></li><li><p>可以使用组合型和非组合型来限定数组类型</p></li><li><p><code>struct packed &#123; bit [7:0] r ,g, b; &#125; pixel;</code></p></li></ul><h4 id="1-6-1-声明和创建"><a href="#1-6-1-声明和创建" class="headerlink" title="1.6.1 声明和创建"></a>1.6.1 声明和创建</h4><ul><li><p>使用struct创建结构</p><ul><li><code>struct &#123; bit [7:0] r ,g, b; &#125; pixel;</code></li></ul></li><li><p>使用typedef创建新类型，利用新类型声明更多的变量</p><ul><li><code>typedef struct &#123; bit [7:0] r, g, b; &#125; pixel_s;</code></li></ul></li><li><p>声明： <code>pixel_s my_pixel;</code></p></li></ul><h4 id="1-6-2-赋值"><a href="#1-6-2-赋值" class="headerlink" title="1.6.2 赋值"></a>1.6.2 赋值</h4><ul><li><p>单个赋值</p></li><li><p><code>my_pixel = &#39;&#123;&#39;h10, &#39;h10, &#39;h10&#125;;</code></p></li><li><p>结构体名.变量名</p></li><li><p><code>my_pixel.r = &#39;h10;</code></p></li></ul><h3 id="1-7-枚举类型"><a href="#1-7-枚举类型" class="headerlink" title="1.7 枚举类型"></a>1.7 枚举类型</h3><ul><li><p>规范的操作码更有利于代码的编写和维护</p></li><li><p>枚举类型 enum 经常和 typedef 搭配使用，便于共享使用，不加 typedef 默认为缺省类型</p><ul><li><code>typedef enum &#123;INIT, DECODE, IDLE&#125; fsmstate_e;</code></li></ul></li><li><p>可以通过 XX.name() 来获取枚举类型的值的值</p></li><li><p>将枚举类型转换为整型时INIT，DECODE，IDLE默认分别为0，1，2</p></li><li><p>枚举类型能直接复制给整型，整型不能直接复制给枚举类型，需要进行格式转换</p></li><li><p>枚举类型默认为int型，SV中可以指定类型</p><ul><li>t<code>ypedef enum bit &#123;INIT, DECODE, IDLE&#125; fsmstate_e;</code></li></ul></li><li><p>枚举类型可以被赋值，但是值必须依次增加</p><ul><li>{INT &#x3D; 1, DECODE &#x3D; 2, IDLE &#x3D; 3}</li></ul></li></ul><h3 id="1-8-字符串"><a href="#1-8-字符串" class="headerlink" title="1.8 字符串"></a>1.8 字符串</h3><ul><li><p>存储单元为byte类型</p></li><li><p>没有空字符，内存是动态分配的</p></li></ul><h4 id="1-8-1-声明和赋值"><a href="#1-8-1-声明和赋值" class="headerlink" title="1.8.1 声明和赋值"></a>1.8.1 声明和赋值</h4><ul><li><p><code>string s;</code></p></li><li><p><code>s[0] = &quot;h&quot;;</code></p></li><li><p>注意：字符串索引从左到右为0，1，2…</p></li></ul><h4 id="1-8-2-字符串方法"><a href="#1-8-2-字符串方法" class="headerlink" title="1.8.2 字符串方法"></a>1.8.2 字符串方法</h4><ul><li><p>获取第X个字符</p><ul><li><code>s.getc(0);</code></li></ul></li><li><p>改变大小写</p><ul><li><code>s.tolower();</code></li></ul></li><li><p>获取字符串长度</p><ul><li><code>s.len();</code></li></ul></li><li><p>改变最后一个字符</p><ul><li><code>s.putc(s.len()-1, &quot;-&quot;);</code></li></ul></li><li><p>获取第2到5个字符</p><ul><li><code>s.substr(2, 5);</code></li></ul></li><li><p>字符串转化为整型</p><ul><li><p>十进制</p><ul><li><code>str.atoi();</code></li></ul></li><li><p>十六进制</p><ul><li><code>str.atohex();</code></li></ul></li><li><p>八进制</p><ul><li><code>str.atooct();</code></li></ul></li><li><p>二进制</p><ul><li><code>str.atobin();</code></li></ul></li></ul></li><li><p>整型转换为字符串</p><ul><li><p>十进制</p><ul><li><code>i1.itoa();</code></li></ul></li></ul></li><li><p>生成新的字符串</p><ul><li><code>$sformatf();</code></li></ul></li><li><p>{} 拼接</p><ul><li><code>$psprintf();</code></li></ul></li></ul><h3 id="1-9-自定义类型-SV新加"><a href="#1-9-自定义类型-SV新加" class="headerlink" title="1.9 自定义类型(SV新加)"></a>1.9 自定义类型(SV新加)</h3><ul><li><p>typedef</p><ul><li><p>typedef enum</p></li><li><p>typedef struct</p></li></ul></li></ul><h2 id="2-方法和过程块"><a href="#2-方法和过程块" class="headerlink" title="2. 方法和过程块"></a>2. 方法和过程块</h2><h3 id="2-1-过程块"><a href="#2-1-过程块" class="headerlink" title="2.1 过程块"></a>2.1 过程块</h3><ul><li><p>always</p><ul><li>always是硬件层面的，是可综合的，用来设计</li></ul></li><li><p>initial</p><ul><li>initial是软件层面的，是不可综合的，用来验证和测试</li></ul></li></ul><h3 id="2-2-软件方法——函数function"><a href="#2-2-软件方法——函数function" class="headerlink" title="2.2 软件方法——函数function"></a>2.2 软件方法——函数function</h3><pre><code>  function int dou(input a);  endfunction</code></pre><ul><li><p>可在参数列表中定义输入参数(input)、输出参数(output)、输入输出参数(inout)、引用参数(ref)</p><ul><li>只有数据变量才能被声明为ref，线网类型不能被声明为ref</li></ul></li><li><p>output在函数和任务结束后才会更新外部数据</p></li><li><p>ref类似指针，是即时更新数据</p></li><li><p>const ref可以检测变量数据但不能修改</p></li><li><p>可以返回数值和不返回数值（void）</p></li><li><p>也可用函数名替代return返回</p><p>  myfunc1 &#x3D; x * y;<br>  return x * y;</p></li><li><p>有返回值但不想使用返回值时，可以用 void’() 将函数转化为无返回值</p></li><li><p>默认的返回类型为logic</p></li><li><p>默认的参数类型为1位宽的logic</p></li><li><p>参数传递时可以跟着名字对应</p><ul><li><code>myfunc1(.y(20));</code></li></ul></li></ul><h3 id="2-3-软件方法——任务task"><a href="#2-3-软件方法——任务task" class="headerlink" title="2.3 软件方法——任务task"></a>2.3 软件方法——任务task</h3><pre><code> task my_task (output logic [31:0] x, input logic y); endtask；</code></pre><ul><li><p>与function的区别</p><ul><li><p>task无法通过return返回结果，只能通过input、output、ref返回</p></li><li><p>能使用return跳出任务</p></li><li><p>task可以内置耗时语句，而function不能</p></li><li><p>function只能用于数字或逻辑运算，task可用于需要耗时的信号采样或驱动场景</p></li><li><p>如果要调用function，则function和task都可调用。如果要调用task，则建议使用task调用，因为task可能含有耗时语句。</p></li><li><p>函数和任务的参数列表都可以为空</p></li></ul></li></ul><h3 id="2-4-变量声明周期"><a href="#2-4-变量声明周期" class="headerlink" title="2.4 变量声明周期"></a>2.4 变量声明周期</h3><ul><li><p>静态static</p><ul><li><p>伴随程序开始到结束一直存在，可被多个方法&#x2F;进程共享</p></li><li><p>static方法， 内部变量默认为static类型，可对内部定义的变量进行单个声明</p></li><li><p>在声明static变量时，应对其进行初始化</p></li><li><p>task、function、module、interface、package、program默认为static类型</p></li></ul></li><li><p>动态automatic</p><ul><li><p>在方法开始时创建，方法结束后被销毁</p></li><li><p>automatic方法，内部变量默认为automatic类型，可对内部定义的变量进行单个声明</p></li></ul></li></ul><h2 id="3-设计例化和连接"><a href="#3-设计例化和连接" class="headerlink" title="3. 设计例化和连接"></a>3. 设计例化和连接</h2><ul><li><p>模块例化</p><ul><li><p>在上层例化底层模块，或TB例化DUT时，均需完成模块例化。</p></li><li><p>例化时需要注意模块名、参数例化传递、例化名和端口例化对应</p></li></ul></li><li><p>模块连接</p><ul><li><p>在testbench中的连接指的是有硬件模块参与作为信号驱动方或负载方</p></li><li><p>两个硬件可由logic类型完成连接</p></li><li><p>硬件与激励连接，需要考虑激励一端如何正确产生数据并发送至DUT一端，同时对DUT的反馈信号做出响应</p></li></ul></li></ul>]]></content>
    
    
    <summary type="html">路科验证SV第一部分学习笔记，整理为markdown形式，原文件为Xmind，可从我的github主页下载</summary>
    
    
    
    <category term="verification" scheme="https://ninglixin98.github.io/categories/verification/"/>
    
    
    <category term="SV" scheme="https://ninglixin98.github.io/tags/SV/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://ninglixin98.github.io/2022/06/09/hello-world/"/>
    <id>https://ninglixin98.github.io/2022/06/09/hello-world/</id>
    <published>2022-06-09T03:29:07.583Z</published>
    <updated>2022-06-09T03:29:07.598Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
